use anchor_lang::{prelude::*, solana_program::clock::Clock};
use ephemeral_vrf_sdk::{
    anchor::vrf,
    instructions::{create_request_randomness_ix, RequestRandomnessParams},
    types::SerializableAccountMeta,
};

use crate::{
    errors::RaffleError,
    state::{RaffleState, RAFFLE_SEED},
};

// The DISCRIMINATOR is generated by the top-level #[program] macro in
// an instruction (singular) module, which should not be confused with
// our instructions  (plural) module.
const DRAW_WINNER_CALLBACK_DISCRIMINATOR: &[u8] =
    crate::instruction::DrawWinnerCallback::DISCRIMINATOR;

pub fn draw_winner_impl(ctx: Context<DrawWinner>) -> Result<()> {
    let oracle_payer = &ctx.accounts.oracle_payer;
    let oracle_queue = &ctx.accounts.oracle_queue;
    let raffle_state = &mut ctx.accounts.raffle_state;
    require!(
        raffle_state.winner_index.is_none(),
        RaffleError::WinnerAlreadyDrawn
    );
    require!(
        raffle_state.entrants.len() > 0,
        RaffleError::RaffleStateDataInvalid
    );
    let clock: Clock = Clock::get()?;
    require!(
        raffle_state.is_raffle_over(&clock),
        RaffleError::RaffleNotOver
    );

    raffle_state.draw_winner_started = true;

    msg!("Requesting randomness...");
    let ix = create_request_randomness_ix(RequestRandomnessParams {
        payer: oracle_payer.key(),
        oracle_queue: oracle_queue.key(),
        callback_program_id: crate::ID,
        callback_discriminator: DRAW_WINNER_CALLBACK_DISCRIMINATOR.to_vec(),
        caller_seed: *raffle_state.key().as_array(),
        // Account required by the callback
        accounts_metas: Some(vec![SerializableAccountMeta {
            pubkey: raffle_state.key(),
            is_signer: false,
            is_writable: true,
        }]),
        ..Default::default()
    });
    msg!("instruction request complete");
    ctx.accounts
        .invoke_signed_vrf(&oracle_payer.to_account_info(), &ix)?;
    msg!("invoke_signed_vrf complete");

    Ok(())
}

pub fn draw_winner_callback_impl(
    ctx: Context<DrawWinnerCallback>,
    randomness: [u8; 32],
) -> Result<()> {
    let raffle_state = &mut ctx.accounts.raffle_state;
    require!(
        raffle_state.draw_winner_started,
        RaffleError::DrawWinnerNotStarted
    );

    let randomness_str: String = randomness
        .iter()
        .map(|byte| format!("{:02x}", byte))
        .collect();
    msg!("Received random data: 0x{}", randomness_str);

    let random_num = ephemeral_vrf_sdk::rnd::random_u64(&randomness) as usize;
    let winner_index = random_num % raffle_state.entrants.len();
    raffle_state.winner_index = Some(winner_index as u32);

    emit!(WinnerDrawnEvent {
        raffle_state: raffle_state.key(),
        winner_index: winner_index as u32,
        winner: raffle_state.entrants[winner_index],
    });

    Ok(())
}

#[vrf]
#[derive(Accounts)]
pub struct DrawWinner<'info> {
    #[account(mut)]
    pub oracle_payer: Signer<'info>,
    #[account(
        mut,
        seeds = [
            RAFFLE_SEED.as_bytes(),
            raffle_state.raffle_manager.key().as_ref(),
            raffle_state.end_time.to_le_bytes().as_ref()
        ],
        bump
    )]
    pub raffle_state: Account<'info, RaffleState>,
    /// CHECK: The oracle queue
    #[account(mut, address = ephemeral_vrf_sdk::consts::DEFAULT_QUEUE)]
    pub oracle_queue: AccountInfo<'info>,
    pub system_program: Program<'info, System>, // TODO: is this needed?
}

#[derive(Accounts)]
pub struct DrawWinnerCallback<'info> {
    /// This check ensure that the vrf_program_identity (which is a PDA)
    /// is a singer enforcing the callback is executed by the VRF program
    /// through CPI.
    #[account(address = ephemeral_vrf_sdk::consts::VRF_PROGRAM_IDENTITY)]
    pub vrf_program_identity: Signer<'info>,
    #[account(
        mut,
        seeds = [
            RAFFLE_SEED.as_bytes(),
            raffle_state.raffle_manager.key().as_ref(),
            raffle_state.end_time.to_le_bytes().as_ref()
        ],
        bump
    )]
    pub raffle_state: Account<'info, RaffleState>,
}

#[event]
pub struct WinnerDrawnEvent {
    pub raffle_state: Pubkey,
    pub winner_index: u32,
    pub winner: Pubkey,
}
