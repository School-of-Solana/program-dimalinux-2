use anchor_lang::prelude::*;
use ephemeral_vrf_sdk::{
    anchor::vrf,
    instructions::{create_request_randomness_ix, RequestRandomnessParams},
    types::SerializableAccountMeta,
};

use crate::{
    errors::RaffleError,
    state::{RaffleState, RAFFLE_SEED},
};

// The DISCRIMINATOR is generated by the top-level #[program] macro
// and not the instructions (plural) module of the folder here.
const DRAW_WINNER_CALLBACK_DISCRIMINATOR: &[u8] =
    crate::instruction::DrawWinnerCallback::DISCRIMINATOR;

pub(crate) fn draw_winner_impl(ctx: Context<DrawWinner>) -> Result<()> {
    let oracle_payer = &ctx.accounts.oracle_payer;
    let oracle_queue = &ctx.accounts.oracle_queue;
    let raffle_state = &mut ctx.accounts.raffle_state;

    raffle_state.draw_winner_started = true;

    let ix = create_request_randomness_ix(RequestRandomnessParams {
        payer: oracle_payer.key(),
        oracle_queue: oracle_queue.key(),
        callback_program_id: crate::ID,
        callback_discriminator: DRAW_WINNER_CALLBACK_DISCRIMINATOR.to_vec(),
        caller_seed: *raffle_state.key().as_array(),
        // Account required by the callback
        accounts_metas: Some(vec![SerializableAccountMeta {
            pubkey: raffle_state.key(),
            is_signer: false,
            is_writable: true,
        }]),
        ..Default::default()
    });

    ctx.accounts
        .invoke_signed_vrf(&oracle_payer.to_account_info(), &ix)?;

    Ok(())
}

#[vrf]
#[derive(Accounts)]
pub struct DrawWinner<'info> {
    /// Payer for the VRF request and any CPI fees; must sign.
    #[account(mut)]
    pub oracle_payer: Signer<'info>,
    /// Raffle state PDA derived from [RAFFLE_SEED, raffle_manager, ticket_price, max_tickets, end_time].
    /// This instruction sets `draw_winner_started`; its address is used as the VRF caller seed.
    #[account(
        mut,
        seeds = [
            RAFFLE_SEED.as_bytes(),
            raffle_state.raffle_manager.key().as_ref(),
            raffle_state.ticket_price.to_le_bytes().as_ref(),
            raffle_state.max_tickets.to_le_bytes().as_ref(),
            raffle_state.end_time.to_le_bytes().as_ref()
        ],
        bump,
        // Ensure winner hasn't been drawn yet
        constraint = raffle_state.winner_index.is_none()
            @ RaffleError::WinnerAlreadyDrawn,
        // Require at least one entrant (raffle manager can close if empty)
        constraint = !raffle_state.entrants.is_empty()
            @ RaffleError::NoEntrants,
        // Check if raffle has ended (either max tickets sold or time elapsed)
        constraint = raffle_state.entrants.len() >= raffle_state.max_tickets as usize
            || clock.unix_timestamp >= raffle_state.end_time
            @ RaffleError::RaffleNotOver
    )]
    pub raffle_state: Account<'info, RaffleState>,
    /// CHECK: Oracle queue (must match DEFAULT_QUEUE constant).
    #[account(mut, address = ephemeral_vrf_sdk::consts::DEFAULT_QUEUE)]
    pub oracle_queue: AccountInfo<'info>,
    /// Clock sysvar for timestamp validation.
    pub clock: Sysvar<'info, Clock>,
}
